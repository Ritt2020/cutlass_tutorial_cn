# CuTe 布局代数 (Layout Algebra)

> CuTe 提供了一套完整的"布局代数"，支持以各种方式组合和操作布局。学会了基础的 Layout 后，布局代数将帮助你组合、切分、重塑这些布局，实现复杂的数据排列和访问模式。
> 这一部分的内容真的很难很复杂，如果阅读吃力，可以考虑暂时跳过，需要用到本节内容时再来查询。
>
> **配套代码示例**：[code/04_cute_layout_algebra](../code/04_cute_layout_algebra)
>

## 环境要求
+ CUTLASS 3.x
+ NVCC with C++ 17

## 核心概念

布局代数基于一个核心理念：**布局是从整数到整数的函数**（Layouts are functions from integers to integers）。

基于这个理念，CuTe 定义了五种基本操作：

| 操作 | 英文名 | 功能 | 应用场景 |
|------|--------|------|----------|
| 合并 | Coalesce | 简化布局，减少模式数量 | 优化布局表示 |
| 组合 | Composition | 函数组合，将两个布局串联 | 重塑张量、数据转换 |
| 补集 | Complement | 计算布局的"剩余空间" | 确定重复模式 |
| 除法 | Division (Tiling) | 将布局按另一个布局切分 | 数据分块、线程分区 |
| 乘积 | Product (Tiling) | 按另一个布局重复当前布局 | 创建重复模式 |

### 形象理解

可以用整理书架来类比这些操作：

- **Coalesce（合并）**：把相邻的空格合并成一个大空格，简化整理
- **Composition（组合）**：在书架上贴标签，一层标签是书名，另一层标签是作者
- **Complement（补集）**：计算还剩多少空位可以放新书
- **Division（除法）**：把书架分成若干个区域，每个区域放不同类型的书
- **Product（乘积）**：买了新书架，按照原来的分类方式复制到新书架上

---

## 1. Coalesce（合并）

### 功能：简化布局表示，但保持功能不变

想象你的抽屉里有这样的分隔：
```
[书 | | 笔 笔 | 橡皮 橡皮 橡皮]
```
你发现中间有两个空格可以合并，最后变成：
```
[书 |（空）| 笔 笔 | 橡皮 橡皮 橡皮]
```

**Coalesce 就是做这件事**：把布局中冗余的部分简化，但不改变任何元素的实际位置。

### 合并规则

对于两个整数模式 `s0:d0` 和 `s1:d1`，定义二元合并操作 `s0:d0 ++ s1:d1`，有4种情况：

| 情况 | 规则 | 说明 |
|------|------|------|
| 1 | `s0:d0 ++ _1:d1 => s0:d0` | 忽略大小为 1 的右模式 |
| 2 | `_1:d0 ++ s1:d1 => s1:d1` | 忽略大小为 1 的左模式 |
| 3 | `s0:d0 ++ s1:s0*d0 => s0*s1:d0` | 连续模式可合并 |
| 4 | `s0:d0 ++ s1:d1 => (s0,s1):(d0,d1)` | 其他情况保持独立 |

### 示例

#### 示例 1：嵌套布局变简单

```cpp
// 复杂的嵌套结构：(2, (1, 6))
auto complex = make_layout(make_shape(Int<2>{}, make_shape(Int<1>{}, Int<6>{})),
                           make_stride(Int<1>{}, make_stride(Int<6>{}, Int<2>{})));

// 合并后：12 个元素，步长为 1（简单多了！）
auto simple = coalesce(complex);  // 结果: _12:_1
```

**为什么能合并？** 因为这 12 个元素实际上是连续排列的。

#### 示例 2：列主序的自动合并

```cpp
// 2×4 的列主序矩阵
auto matrix = make_layout(make_shape(Int<2>{}, Int<4>{}));  // (_2,_4):(_1,_2)

// 合并后变成 8 个连续元素
auto simple = coalesce(matrix);  // 结果: _8:_1
```

**可视化理解**：
```
原始（2×4矩阵）:        合并后（8个元素）:
  0  2  4  6              0  1  2  3  4  5  6  7
  1  3  5  7
  
内存中都是: [0][1][2][3][4][5][6][7]（连续的）
```

#### 示例 3：无法合并的情况（有间隔）

```cpp
// 有 padding 的布局
auto padded = make_layout(make_shape(Int<2>{}, Int<4>{}),
                         make_stride(Int<6>{}, Int<1>{}));

auto result = coalesce(padded);  // 无法简化，保持原样
```

**为什么无法合并？** 因为元素之间有间隔（padding），不是连续的。

```
内存布局: [0][1][2][3][ ][ ][6][7][8][9][ ][ ]
                        ↑空洞↑        ↑空洞↑
```

### 按模式合并（By-mode Coalesce）

有时候我们希望保持原来的维度结构（比如保持2D矩阵的样子），只在每个维度内部简化：

```cpp
auto complex = Layout<Shape <_2,Shape <_1,_6>>,
                      Stride<_1,Stride<_6,_2>>>{};

// 保持 2 维结构的合并
auto result = coalesce(complex, Step<_1,_1>{});   // (_2,_6):(_1,_2)
```

**效果对比**：
- 普通 `coalesce`：`(2,(1,6))` → `12`（变成1维）
- 按模式 `coalesce`：`(2,(1,6))` → `(2,6)`（保持2维）

**使用场景**：当你希望布局"看起来"还是个矩阵，但内部尽量简化时。

---

## 2. Composition（组合）

### 功能：将两个布局串联起来

**生活中的例子**：

想象你要找一本书：
1. 第一层映射（B）：图书馆目录告诉你 "编号123" 在 "第5排第3列"
2. 第二层映射（A）：书架地图告诉你 "第5排第3列" 对应实际位置 "走廊左侧第10个书架"

**组合后**：直接通过"编号123"就能找到"走廊左侧第10个书架"

### 数学表示

```
组合：R = A ∘ B
意思：R(坐标) = A(B(坐标))
```

就是把 B 的输出作为 A 的输入，**一层套一层**。

### 具体示例

```
假设：
A = (6,2):(8,2)  → 把坐标变成内存地址
B = (4,3):(3,1)  → 把序号变成坐标

组合后 R = A ∘ B：直接从序号到内存地址

示例计算：
R(0) = A(B(0)) = A(0) = 0     ← B把0变成0，A再把0变成0
R(1) = A(B(1)) = A(3) = 24    ← B把1变成3，A再把3变成24
R(2) = A(B(2)) = A(6) = 2     ← B把2变成6，A再把6变成2
...
```

### 实际应用：数据重塑

#### 场景 1：一维数组变矩阵

```cpp
// 有 24 个连续的数字: [0,1,2,3,...,23]
auto linear = make_layout(24);

// 想把它看作 4×6 的矩阵
auto matrix_shape = make_layout(make_shape(Int<4>{}, Int<6>{}));

// 组合：输入矩阵坐标 (i,j)，输出对应的数字
auto reshaped = composition(matrix_shape, linear);
```

**效果**：
```
线性: [0][1][2][3][4][5]...[23]
           ↓ 组合变换 ↓
矩阵:  0  4  8  12  16  20
       1  5  9  13  17  21
       2  6  10  14  18  22
       3  7  11  15  19  23
```

#### 场景 2：行主序 → 列主序

```cpp
// 原数据是行主序：[0 1 2 | 3 4 5]（2行3列）
auto row_major = make_layout(make_shape(Int<2>{}, Int<3>{}),
                            make_stride(Int<3>{}, Int<1>{}));

// 想用列主序访问
auto col_major = make_layout(make_shape(Int<2>{}, Int<3>{}),
                            make_stride(Int<1>{}, Int<2>{}));

// 组合实现转换
auto transformed = composition(col_major, row_major);
```

**关键理解**：Composition 就像"翻译"，把一种访问方式翻译成另一种。

---

## 3. Complement（补集）

### 功能：给定一个"模板"，计算需要重复多少次

**生活中的例子**：

你有一个 4 格的鸡蛋盒（这是"模板"），现在有 12 个鸡蛋要装。
- **问题**：需要几个这样的盒子？怎么排列？
- **答案**：需要 3 个盒子（12 ÷ 4 = 3）

**Complement 就是计算这个"3"以及盒子的排列方式。**

### 数学定义

```
已知：
  - 模板大小 = 4 个格子
  - 总空间 = 12 个格子
  
求：
  - 补集大小 = 12 ÷ 4 = 3（需要3个模板）
  - 补集布局 = 如何摆放这3个模板
```

公式：
```
size(A) * size(A*) = N
cosize(A*) * size(A*) = N
```

### 示例

#### 示例 1：4个元素的模板，填满12个空间

```cpp
// 模板：4 个连续元素
auto tile = make_layout(make_shape(Int<4>{}), make_stride(Int<1>{}));

// 计算在总大小12下的补集
auto repeat_pattern = complement(tile, 12);
// 结果: _3:_4 → 重复3次，每次跳过4个位置
```

**可视化**：
```
Tile 0: [0][1][2][3]____________________
Tile 1: ____________[4][5][6][7]________
Tile 2: ________________________[8][9][10][11]
```

#### 示例 2：2×2 的模板，填满16个空间

```cpp
// 模板：2×2 的小方块
auto tile = make_layout(make_shape(Int<2>{}, Int<2>{}),
                       make_stride(Int<1>{}, Int<4>{}));

// 计算补集
auto repeat_pattern = complement(tile, 16);
// 告诉你这个2×2的方块要重复几次，怎么排列
```

**效果**：
```
原始 2×2 tile:    重复模式:
  0  4              0  4  |  2  6
  1  5              1  5  |  3  7
                   ---------------------
                    8  12 |  10  14
                    9  13 |  11  15
```

**使用场景**：当你需要知道"某个模式要重复多少次才能填满整个空间"时。

---

## 4. Division / Tiling（除法/切分）

### 功能：把大数据切成小块，方便分配

**生活中的例子**：

你有一个 24 寸的大披萨，要分给 4 个人：
- **切分方式**：每人 6 寸（24 ÷ 4 = 6）
- **结果**：4 块披萨，每块 6 寸

**Division 就是做这件事**：把大布局切成小块，告诉你每块的大小和有多少块。

### 返回值

`logical_divide` 返回一个 rank-2 的布局，包含两部分信息：

```cpp
auto result = logical_divide(layout_A, layout_B);
// 结果包含两部分：
//   - Mode-0: tile（单个块的布局）
//   - Mode-1: repetition（块的重复模式）
```

**后置条件**：
```cpp
// @post rank(result) == 2
// @post size<0>(result) == size(tiler)
// @post size<1>(result) == size(layout) / size(tiler)
// @post size(result) == size(layout)
```

### 示例 1：分配给线程

```cpp
// 有 128 个数据
auto data = make_layout(make_shape(Int<128>{}));

// 分给 32 个线程（1个 warp）
auto threads = make_layout(make_shape(Int<32>{}));

// 切分！
auto result = logical_divide(data, threads);
// Mode-0: 每个线程拿 4 个元素（128÷32=4）
// Mode-1: 有 32 个线程
```

**可视化**：
```
原始: [0][1][2][3]...[127] （128个元素）
         ↓ 切分给32个线程 ↓
Thread 0:  [0][1][2][3]
Thread 1:  [4][5][6][7]
Thread 2:  [8][9][10][11]
...
Thread 31: [124][125][126][127]
```

### 示例 2：矩阵分块

```cpp
// 大矩阵：6×20
auto matrix = make_layout(make_shape(Int<6>{}, Int<20>{}));

// 切成 2×5 的小块
auto tile_size = make_shape(Int<2>{}, Int<5>{});

// 切分！
auto result = logical_divide(matrix, tile_size);
// 结果：3×4 = 12 个小块，每块 2×5
```

**可视化**：
```
原始 6×20 矩阵:
┌────────────────────┐
│                    │  切成→  ┌──┬──┬──┬──┐
│    6 × 20          │         │  │  │  │  │ ← 每块 2×5
│                    │         ├──┼──┼──┼──┤
└────────────────────┘         │  │  │  │  │
                               ├──┼──┼──┼──┤
                               │  │  │  │  │
                               └──┴──┴──┴──┘
                                 3×4 = 12块
```

### 不同的切分方式

CuTe 提供了几种不同的切分方式，它们返回的结果**组织形式不同**，但描述的是同一件事。

#### Zipped Divide（压缩切分）

```cpp
auto result = zipped_divide(layout, tile);
// 结果形式: ((M,N), (TileM,TileN))
```

保持原始维度结构，把 tile 信息压缩在一起。

#### Tiled Divide（平铺切分）

```cpp
auto result = tiled_divide(layout, tile);
// 结果形式: ((M,N), TileM, TileN)
```

保持原维度，但把 tile 的各个维度展开。

#### Flat Divide（扁平切分）

```cpp
auto result = flat_divide(layout, tile);
// 结果形式: (M, N, TileM, TileN)
```

完全扁平化，所有维度都展开。

### 分块模式对比

| 切分方式 | 结果形式 | 适用场景 |
|---------|---------|---------|
| **logical_divide** | `((tile), (blocks))` | 基本逻辑分块 |
| **zipped_divide** | `((M,N), (TileM,TileN))` | 保持原矩阵结构 |
| **tiled_divide** | `((M,N), TileM, TileN)` | 独立访问 tile 维度 |
| **flat_divide** | `(M, N, TileM, TileN)` | 完全扁平化 |

**注意**：当 tiler 是 `Layout` 类型时，`zipped_divide` 和 `logical_divide` 的结果相同。

---

## 5. Product（乘积）

### 功能：按某种模式重复一个布局

**生活中的例子**：

你设计了一个 2×5 的瓷砖图案，现在要铺满一个 6×20 的墙面：
- **做法**：把这个图案重复 3×4 = 12 次
- **结果**：整面墙都是你的图案

**Product 就是做这件事**：把一个"模板"按规定的次数和方式重复。

### 与 Division 的关系

Division 和 Product 是互逆的操作：

| 操作 | 方向 | 说明 |
|------|------|------|
| Division | 大 → 小 | 128 个元素 ÷ 32 = 每份 4 个元素 |
| Product | 小 → 大 | 4 个元素 × 32 次 = 128 个元素 |

### 示例 1：简单重复

```cpp
// 模板：4 个元素排成 (2,2)
auto tile = make_layout(make_shape(Int<2>{}, Int<2>{}),
                       make_stride(Int<4>{}, Int<1>{}));

// 重复 6 次
auto repeat = make_layout(make_shape(Int<6>{}));

// 乘积！
auto result = logical_product(tile, repeat);
// 结果：6 个这样的 tile
```

**可视化**：
```
原始 tile:      重复6次:
  0  4           0  4 | 2  6 | 8  12 | 10  14 | 16  20 | 18  22
  1  5           1  5 | 3  7 | 9  13 | 11  15 | 17  21 | 19  23
                 ←─tile 0──┘├─tile 1─┤...
```

### 示例 2：2D 模式重复

```cpp
// 模板：2×5 的图案
auto tile = make_layout(make_shape(Int<2>{}, Int<5>{}));

// 重复成 3×4 的网格
auto grid = make_layout(make_shape(Int<3>{}, Int<4>{}));

// 乘积！
auto result = blocked_product(tile, grid);
// 结果：(6,20) 的大矩阵
```

**可视化**：
```
原始 2×5 tile:      重复成 3×4 网格:
┌──────┐           ┌──────┬──────┬──────┬──────┐
│ 图案 │    →      │ 图案 │ 图案 │ 图案 │ 图案 │
└──────┘           ├──────┼──────┼──────┼──────┤
                   │ 图案 │ 图案 │ 图案 │ 图案 │
                   ├──────┼──────┼──────┼──────┤
                   │ 图案 │ 图案 │ 图案 │ 图案 │
                   └──────┴──────┴──────┴──────┘
```

### 不同的乘积方式

类似 Division，Product 也有不同的变体：

#### Blocked Product（块状重复）

```cpp
auto result = blocked_product(tile, grid);
// 特点：tile 完整地一块一块排列
```

Tile 完整地排列成块，先完成一个 tile，再到下一个。

#### Raked Product（交错重复）

```cpp
auto result = raked_product(tile, grid);
// 特点：tile 的元素交错排列
```

Tile 元素交错排列，类似于"cyclic distribution"。

#### 其他变体

```cpp
auto result = zipped_product(A, B);   // 压缩形式: ((M,N), (TileM,TileN,...))
auto result = tiled_product(A, B);    // 平铺形式: ((M,N), TileM, TileN, ...)
```

---

## 实际应用场景

### 场景 1：GEMM 矩阵分块

**问题**：128×128 的矩阵太大，要分成小块处理。

```cpp
// 大矩阵
auto matrix = make_layout(make_shape(Int<128>{}, Int<128>{}));

// 分成 16×16 的小块
auto tile = make_shape(Int<16>{}, Int<16>{});
auto tiled = tiled_divide(matrix, tile);

// 结果：8×8 = 64 个小块，每块 16×16
```

**用在哪？** 
- 矩阵乘法（GEMM）
- 卷积（Convolution）  
- 任何需要分块计算的地方

### 场景 2：分配给线程

**问题**：128 个数据要分给 32 个线程处理。

```cpp
// 数据
auto data = make_layout(make_shape(Int<128>{}));

// 32 个线程（1个 warp）
auto threads = make_layout(make_shape(Int<32>{}));

// 切分！
auto per_thread = logical_divide(data, threads);
// 每个线程拿 4 个元素（128÷32=4）
```

**用在哪？**
- CUDA kernel 中的数据分配
- 共享内存的划分
- 寄存器的分配

### 场景 3：数据格式转换

**问题**：数据是行主序，但我想用列主序访问。

```cpp
// 原数据：行主序
auto row_major = make_layout(make_shape(Int<M>{}, Int<N>{}),
                            make_stride(Int<N>{}, Int<1>{}));

// 目标：列主序
auto col_major = make_layout(make_shape(Int<M>{}, Int<N>{}),
                            make_stride(Int<1>{}, Int<M>{}));

// 组合转换
auto transform = composition(col_major, row_major);
```

**用在哪？**
- 矩阵转置
- 数据重排
- 兼容不同库的数据格式

### 场景 4：Tensor Core 数据对齐

**问题**：Tensor Core 对数据排列有特殊要求。

```cpp
// 创建符合 Tensor Core 要求的复杂布局
auto tc_layout = make_layout(
    make_shape(make_shape(Int<16>{}, Int<16>{}),
               make_shape(Int<8>{}, Int<8>{})),
    make_stride(make_stride(Int<1>{}, Int<16>{}),
                make_stride(Int<256>{}, Int<4096>{}))
);
```

**用在哪？**
- 利用 Tensor Core 加速矩阵乘法
- WMMA 操作
- 高性能 GEMM 实现

---

## 快速上手指南

### 步骤 1：选择合适的操作

| 你想做什么 | 用什么操作 | 代码示例 |
|-----------|----------|---------|
| 简化复杂布局 | `coalesce` | `coalesce(layout)` |
| 数据格式转换 | `composition` | `composition(A, B)` |
| 把大数据分给线程 | `logical_divide` | `logical_divide(data, threads)` |
| 重复一个模式 | `logical_product` | `logical_product(tile, grid)` |
| 计算重复次数 | `complement` | `complement(tile, total_size)` |

### 步骤 2：记住三个要点

1. **静态优于动态**：尽量用 `Int<N>{}` 而不是 `int n`
2. **简化优先**：复杂布局先用 `coalesce` 简化
3. **可视化调试**：不确定就用 `print_layout()` 看看

### 步骤 3：常见组合模式

```cpp
// 模式1：矩阵分块 + 线程分配
auto tiled = tiled_divide(matrix, tile_size);  // 先分块
auto per_thread = logical_divide(tiled, threads);  // 再分线程

// 模式2：重塑 + 转置
auto reshaped = composition(new_shape, old_layout);  // 先重塑
auto transposed = composition(col_major, reshaped);  // 再转置

// 模式3：先简化 + 再切分
auto simple = coalesce(complex_layout);  // 先简化
auto divided = tiled_divide(simple, tile);  // 再切分
```

---

## 性能优化技巧

| 优化项 | 慢 | 快 | 提升 |
|--------|------|------|------|
| 大小类型 | `int n = 128` | `Int<128>{}` | 编译时优化 |
| 布局复杂度 | 嵌套3-4层 | `coalesce` 后1-2层 | 减少计算 |
| 访问模式 | 跨步访问 | 连续访问（stride=1） | 内存合并 |
| Padding | 无padding | 适当padding（避免bank conflict） | 减少冲突 |

---

## 调试技巧

### 快速查看布局

```cpp
// 方法1：简单打印
print(layout); print("\n");

// 方法2：详细信息
print("Shape:  "); print(shape(layout)); print("\n");
print("Stride: "); print(stride(layout)); print("\n");
print("Size:   "); print(size(layout)); print("\n");

// 方法3：可视化（只适用于2D布局）
print_layout(layout);
```

### 常见错误自查清单

- **切分时**：size 能被整除吗？（`size(A) % size(B) == 0`）
- **补集时**：目标size是倍数吗？（`target % size(tile) == 0`）
- **组合时**：输入输出size匹配吗？（`size(A) == cosize(B)`）
- **性能差**：是不是用了动态大小？改成静态试试！

---

## 常见错误与解决方案

### 错误 1：Size 不匹配

```cpp
// 错误
auto A = make_layout(make_shape(Int<100>{}));
auto B = make_layout(make_shape(Int<32>{}));
auto result = logical_divide(A, B);  // 100 不能被 32 整除！
```

**解决方案**：确保 `size(A)` 能被 `size(B)` 整除。

### 错误 2：Complement 大小不合适

```cpp
// 错误
auto A = make_layout(make_shape(Int<10>{}));
auto A_star = complement(A, 15);  // 15 不能被 10 整除！
```

**解决方案**：确保目标大小是原布局大小的整数倍。

### 错误 3：混用动态和静态大小

```cpp
// 不推荐（性能较差）
auto layout = make_layout(make_shape(Int<128>{}, n));  // n 是运行时变量

// 推荐（编译时优化）
auto layout = make_layout(make_shape(Int<128>{}, Int<64>{}));
```

---

## 实践：布局代数综合应用

本节通过几个实践任务来综合运用前面学到的布局代数知识。

### 任务 1：简化复杂布局

创建一个嵌套布局 `(4, (2, 3)):(1, (4, 8))`，然后使用 `coalesce` 简化它。

**要求**：
- 使用静态大小创建布局
- 使用 `coalesce` 简化
- 验证简化前后 `size` 保持不变（应为 24）
- 观察 stride 是否连续

---

### 任务 2：矩阵格式转换

有一个 8×12 的行主序矩阵，使用 `composition` 将其转换为列主序访问。

**要求**：
- 创建行主序布局：`(8,12):(12,1)`
- 创建列主序布局：`(8,12):(1,8)`
- 使用 `composition` 实现格式转换
- 验证几个位置的索引是否正确

---

### 任务 3：GEMM 矩阵分块

为 128×128 的矩阵设计两级分块策略：
1. 第一级：分成 32×32 的 Thread Block（4×4 = 16 个 Block）
2. 第二级：每个 Block 内分成 4×4 的 Thread 块（8×8 = 64 个 Thread）

**要求**：
- 使用 `tiled_divide` 实现第一级分块
- 对单个 32×32 块再次使用 `tiled_divide` 实现第二级分块
- 验证每一级的大小：
  - 原始：128×128 = 16384 个元素
  - Block 级：16 个 Block，每个 1024 个元素
  - Thread 级：64 个 Thread/Block，每个 16 个元素

---

### 任务 4：Tile 重复模式

设计一个 2×5 的 tile，使用 `blocked_product` 将其重复成 6×20 的矩阵。

**要求**：
- 创建 2×5 的 tile 布局
- 计算重复次数：需要 3×4 = 12 次重复
- 使用 `blocked_product` 创建重复模式
- 验证结果 shape 为 (6, 20)，size 为 120

---

### 实践

参考代码示例：[code/04_cute_layout_algebra/layout_algebra.cu](../code/04_cute_layout_algebra/layout_algebra.cu)

