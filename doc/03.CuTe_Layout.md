> CuTe 是处理多维数据（Tensor）的模板抽象。学会了 CuTe 之后，你将会描述不同情形下的多维矩阵，而不需要关注矩阵内部具体元素的存取位置细节等，从而利用 CUTLASS 的相关特性。
>
> 📝 **配套代码示例**：[code/03_cute_layout](../code/03_cute_layout)

## 环境要求
+ CUTLASS 3.x
+ NVCC with C++ 17

## 配置说明
+ **CuTe** 是一个仅 **header** 的库。你可以在 CUTLASS 的 **include/** 文件夹下找到。
+ 参考例子在 **CUTLASS** 目录下 **examples/cute/** 内。

## 引入 CuTe
+ 关键组件如下：

| 目录 | 内容 |
| --- | --- |
| [include/cute](https://github.com/NVIDIA/cutlass/tree/main/include/cute) | 每个 header 对应于 CuTe 的基本组件之一，如 [Layout](https://github.com/NVIDIA/cutlass/tree/main/include/cute/layout.hpp) 和 [Tensor](https://github.com/NVIDIA/cutlass/tree/main/include/cute/tensor.hpp)。 |
| [include/cute/container](https://github.com/NVIDIA/cutlass/tree/main/include/cute/container) | 实现类似 STL 的对象，如元组、数组和对齐数组。 |
| [include/cute/numeric](https://github.com/NVIDIA/cutlass/tree/main/include/cute/numeric) | 基本数字数据类型，包括非标准浮点类型、非标准整数类型、复数和整数序列。 |
| [include/cute/algorithm](https://github.com/NVIDIA/cutlass/tree/main/include/cute/algorithm) | 实用程序算法的实现，如 copy, fill, clear。 |
| [include/cute/arch](https://github.com/NVIDIA/cutlass/tree/main/include/cute/arch) | 特定架构的矩阵乘法和复制指令的 wrapper。 |
| [include/cute/atom](https://github.com/NVIDIA/cutlass/tree/main/include/cute/atom) | arch/ 目录的元信息和切分、分块等工具。 |


## 数据类型
### 整数类型
CuTe 提供了 **动态** 和 **静态** 整数类型。

| 特性 / 维度 | 动态整数 (run-time integer) | 静态整数 (compile-time integer) |
| --- | --- | --- |
| C++ 类型表示 | 普通整型，如 `int`, `size_t`, `uint16_t` | `std::integral_constant<Value>` 或 CuTe 的 `cute::C<Value>` / `Int<Value>` |
| 值确定时间 | 运行时才知道 | 编译时已知常量 |
| 与运算交互 | 与静态整数混用；大多数算术运算在运行时执行 | 支持重载算术操作，静态整数运算在编译期折叠为静态整数 |
| trait / 类型判断 | `cute::is_std_integral<T>` 为真；`cute::is_integral<T>` 为真 | `cute::is_static<T>` 为真；`cute::is_integral<T>` 为真；也可用 `cute::is_constant<N, T>` 判断 |
| 占用 / 存储 | 即时值，占用常规模板变量或内存 | 通常为空类型，不占运行时存储（作为类型参数） |
| 应用场景 | 尺寸 / 维度在运行时才知道的情形 | Tile 大小 / 固定维度 / 模板参数等已知常量场景 |
| 可互换性 | 在多数 CuTe 接口中可替换为静态整数 | 同样可以混用成动态整数（转换为普通整型） |


### 元组 Tuple
+ `cute::tuple`：CuTe 提供的元组类型，可在设备（CUDA kernel）和主机端使用，行为类似 `std::tuple`，但对模板参数种类有一定限制以便生成更高效代码。  
+ `IntTuple`：CuTe 定义为“要么是一个整数（动态 / 静态），要么是一个 `tuple`，其每个元素又是 `IntTuple`。通过这个递归定义，CuTe 能表示嵌套结构的维度 / 形状 / 步幅等。  
+ `IntTuple` 的操作包括：`rank(...)`（元素个数），`get<I>(...)`（访问第 I 个元素），`depth(...)`（嵌套深度），`size(...)`（所有整数乘积）等。  
+ `Shape`、`Stride`、`Coord` 等在 CuTe 中都被定义为 `IntTuple` 的别名或实例。

---

#### 示例
下面是一个简单的例子，展示如何用 `cute::tuple` / `make_tuple` 构造一个嵌套的 `IntTuple`，以及如何访问其中的元素：

```cpp
#include <iostream>
#include "cutlass/experimental/cute/container/tuple.hpp"
using namespace cute;

int main() {
  // 一个简单的 IntTuple：动态整数 + 静态整数的组合
  auto t = make_tuple(int{2}, Int<3>{});
  // t 表示 (2, 3)

  // 嵌套结构：第三个元素又是一个 tuple
  auto nested = make_tuple(uint16_t{42},
                           make_tuple(Int<1>{}, int{3}),
                           Int<17>{});
  // nested 表示 (42, (1, 3), 17)

  // 访问元素 使用 get<index>()
  auto e0 = get<0>(nested);           // e0 是 uint16_t{42}
  auto e1 = get<1>(nested);           // e1 是 the tuple (Int<1>, int{3})
  auto e1_1 = get<1>(e1);              // e1_1 是 int{3}
  auto e2 = get<2>(nested);            // e2 是 Int<17>

  std::cout << "e0 = " << int(e0) << "\n";          // 注意可能要转换为 int 打印
  std::cout << "e1.second = " << int(e1_1) << "\n";
  std::cout << "e2 (static) = " << Int<17>{}.value << "\n";

  return 0;
}
```

## 布局 Layout
布局 `Layout` 是一对 `IntTuple`：`Shape` 和 `Stride`。第一个元素定义了 `Layout` 的抽象_形状_，第二个元素定义了_步长_，从形状内的坐标映射到索引空间。

我们在 `Layout` 上定义了许多类似于 `IntTuple` 上定义的操作。

+ `rank(Layout)`：`Layout` 中的模式数量。相当于 `Layout Shape` 的元组的 `Size`。
+ `get<I>(Layout)`: `Layout` 的第 `I` 个布局模式， `I < rank`。
+ `depth(Layout)`：`Layout` 形状的深度。单个整数的深度为 0，整数元组的深度为 1，整数元组的深度为 2，等等。
+ `shape(Layout)`：`Layout` 的**形状**。
+ `stride(Layout)`：`Layout` 的**步长**。
+ `size(Layout)`：`Layout` 函数域的大小。等同于 `size(shape(Layout))`。
+ `cosize(Layout)`：`Layout` 函数协域的大小（不一定是范围）。相当于 `A(size(A)-1)+1`。这个属性，实际上代表了从 **stride** 推理得到的实际上矩阵占用空间。

### 构造布局
+ 构造传入 **shape** 和 **stride**。如果不传入 **stride**，则为默认 **LayoutLeft**。
+ **LayoutLeft** 为从左到右解释 **shape**（列主序）。**LayoutRight** 为从右到左解释 **shape**（行主序）。
+ 这里的关键是理解嵌套的 **Layout**，内层 **Layout** 展开后作为整体。

```cpp
// 一维：大小为 8（静态）
Layout s8 = make_layout(Int<8>{});   
// 等价于 [8]，stride = [1]，编译期常量的一维数组

// 一维：大小为 8（动态）
Layout d8 = make_layout(8);  
// 等价于 [8]，stride = [1]，运行时指定大小


// 二维：2 x 4，静态维度（默认列主序）
Layout s2xs4 = make_layout(make_shape(Int<2>{}, Int<4>{}));  
// shape = [2,4]，stride = [1,2]（列主序 ColumnMajor）
// 内存顺序：先存同一列，再存下一列


// 二维：2 x 4，混合静态和动态维度
Layout s2xd4 = make_layout(make_shape(Int<2>{}, 4));  
// shape = [2,4]，stride = [1,2]，与 s2xs4 等价，只是第二维是动态 int


// 指定 stride 的二维布局
Layout s2xd4_a = make_layout(make_shape(Int<2>{}, 4),
                             make_stride(Int<12>{}, Int<1>{}));  
// shape = [2,4], stride = [12,1]
// 每行之间跨度为 12，实际每行后多留 8 个空位


// 指定列主序（LayoutLeft）
Layout s2xd4_col = make_layout(make_shape(Int<2>{}, 4),
                               LayoutLeft{});  
// shape = [2,4]，stride = [1,2]（列主序 ColumnMajor）
// 内存顺序：先存一列，再存下一列


// 指定行主序（LayoutRight）
Layout s2xd4_row = make_layout(make_shape(Int<2>{}, 4),
                               LayoutRight{});  
// shape = [2,4]，stride = [4,1]（行主序 RowMajor）
// 内存顺序：先存一行，再存下一行


// 层次化布局：2 x (2x2)
Layout s2xh4 = make_layout(make_shape(2, make_shape(2,2)),
                           make_stride(4, make_stride(2,1)));  
// shape = [2,2,2]，stride = [4,2,1]
// 等价于一个 2x4 矩阵，用分层形式表示
// 内存顺序：最后两维 (2x2) 连续，外层步长为 4


// 用列主序重新解释 s2xh4 的 shape
Layout s2xh4_col = make_layout(shape(s2xh4),
                               LayoutLeft{});  
// shape = [2,2,2]，stride = [1,2,4]（列主序）
// 内存顺序：最内层维 stride 最小，最外层维 stride 最大

```

| Layout | rank | size | cosize | stride | 备注 |
| --- | --- | --- | --- | --- | --- |
| s8 / d8 | 1 | 8 | 8 | [1] | 一维 |
| s2xs4 | 2 | 8 | 8 | [1,2] | 默认 ColumnMajor |
| s2xd4 | 2 | 8 | 8 | [1,2] | 同上（第二维动态） |
| s2xd4_a | 2 | 8 | 16 | [12,1] | 有 padding |
| s2xd4_col | 2 | 8 | 8 | [1,2] | ColumnMajor |
| s2xd4_row | 2 | 8 | 8 | [4,1] | RowMajor |
| s2xh4 | 3 | 8 | 8 | [4,2,1] | 分块 2×(2×2) |
| s2xh4_col | 3 | 8 | 8 | [1,2,4] | ColumnMajor |


可以使用 `print2D(), printLayout()` 打印对应布局。

```cpp
> print_layout(s2xs4)
  0    2    4    6
  1    3    5    7
> print_layout(s2xd4_a)
  0    1    2    3
 12   13   14   15
> print_layout(s2xh4_col)
  0    2    4    6
  1    3    5    7
> print_layout(s2xh4)
  0    2    1    3
  4    6    5    7
> print_layout(s2xh4)
(2,(2,2)):(4,(2,1))
      0   1   2   3
    +---+---+---+---+
 0  | 0 | 2 | 1 | 3 |
    +---+---+---+---+
 1  | 4 | 6 | 5 | 7 |
    +---+---+---+---+
```



### 练习
+ 这里是一些练习题目，用于熟悉 Layout 的实现。
+ 请针对每个题目，仔细思考矩阵在二维空间内的元素顺序是怎么样的。然后和答案对比。

#### 题目
```cpp
auto L = make_layout(Int<4>{});

auto L = make_layout(make_shape(Int<2>{}, Int<3>{}),
                     LayoutRight{});

auto L = make_layout(make_shape(Int<2>{}, Int<3>{}),
                     LayoutLeft{});

auto L = make_layout(make_shape(Int<2>{}, Int<4>{}),
                     make_stride(Int<6>{}, Int<1>{}));

auto L = make_layout(make_shape(2, make_shape(2, 3)),
                     make_stride(6, make_stride(3, 1)));

```

#### 答案

**题目 1：一维布局**
```cpp
auto L = make_layout(Int<4>{});
// shape = [4], stride = [1]
```
```
[0, 1, 2, 3]
```

---

**题目 2：行主序 2×3**
```cpp
auto L = make_layout(make_shape(Int<2>{}, Int<3>{}), LayoutRight{});
// shape = [2, 3], stride = [3, 1]（行主序）
```
```
[ 0   1   2 ]
[ 3   4   5 ]
```

---

**题目 3：列主序 2×3**
```cpp
auto L = make_layout(make_shape(Int<2>{}, Int<3>{}), LayoutLeft{});
// shape = [2, 3], stride = [1, 2]（列主序）
```
```
[ 0   2   4 ]
[ 1   3   5 ]
```

---

**题目 4：带 padding 的 2×4**
```cpp
auto L = make_layout(make_shape(Int<2>{}, Int<4>{}),
                     make_stride(Int<6>{}, Int<1>{}));
// shape = [2, 4], stride = [6, 1]
```
```
[ 0   1   2   3 ]
[ 6   7   8   9 ]   // 注意 index=4,5 没用到（padding）
```

---

**题目 5：分层布局 2×(2×3)**
```cpp
auto L = make_layout(make_shape(2, make_shape(2, 3)),
                     make_stride(6, make_stride(3, 1)));
// shape = [2, (2, 3)], stride = [6, (3, 1)]
// 外层2个块，每块是2×3的矩阵
```
```
外层块 0：
[ 0   1   2 ]
[ 3   4   5 ]

外层块 1：
[ 6   7   8 ]
[ 9  10  11 ]
```
或者展平为一个 2×6 矩阵：
```
[ 0   3   1   4   2   5 ]
[ 6   9   7   10  8  11 ]
```
### 打印布局
我们不仅可以通过 `print_layout()` 来打印布局，还可以使用 `print_latex()` 直接获取 **latex** 代码绘图。
如：
```shell
> print_latex(L5);

% Layout: (2,(2,3)):(6,(3,1))
\documentclass[convert]{standalone}
\usepackage{tikz}

\begin{document}
\begin{tikzpicture}[x={(0cm,-1cm)},y={(1cm,0cm)},every node/.style={minimum size=1cm, outer sep=0pt}]

\node[fill=black!00] at (0,0) {0};
\node[fill=black!60] at (0,1) {3};
\node[fill=black!40] at (0,2) {1};
\node[fill=black!10] at (0,3) {4};
\node[fill=black!20] at (0,4) {2};
\node[fill=black!50] at (0,5) {5};
\node[fill=black!30] at (1,0) {6};
\node[fill=black!40] at (1,1) {9};
\node[fill=black!70] at (1,2) {7};
\node[fill=black!20] at (1,3) {10};
\node[fill=black!00] at (1,4) {8};
\node[fill=black!60] at (1,5) {11};
\draw[color=black,thick,shift={(-0.5,-0.5)}] (0,0) grid (2,6);

\node at (0,-1) {\Large{\texttt{0}}};
\node at (1,-1) {\Large{\texttt{1}}};
\node at (-1,0) {\Large{\texttt{0}}};
\node at (-1,1) {\Large{\texttt{1}}};
\node at (-1,2) {\Large{\texttt{2}}};
\node at (-1,3) {\Large{\texttt{3}}};
\node at (-1,4) {\Large{\texttt{4}}};
\node at (-1,5) {\Large{\texttt{5}}};
\end{tikzpicture}
\end{document}
```

输出图像看起来是这样的：
![LATEX 图像](img/latex_layout_l5.png)

## 布局兼容性 (Layout Compatibility)

在 CuTe 中，布局兼容性是一个重要的概念，它定义了不同形状的布局之间何时可以相互转换或组合。

### 定义

我们说**布局 A 与布局 B 兼容**，当且仅当 A 的 shape 与 B 的 shape 兼容。

**Shape A 与 Shape B 兼容**需要满足以下两个条件：

1. A 的 size（元素总数）等于 B 的 size
2. A 中的所有坐标都是 B 中的有效坐标

换句话说，Shape A 可以被"重新解释"为 Shape B，前提是它们具有相同的元素数量，并且 A 的索引方式不会超出 B 的范围。

### 兼容性规则

兼容性是 Shape 上的**弱偏序关系**（weak partial order），因为它具有以下性质：

- **自反性**（Reflexive）：任何 shape 都与自身兼容
- **反对称性**（Antisymmetric）：如果 A 兼容 B 且 B 兼容 A，则 A = B
- **传递性**（Transitive）：如果 A 兼容 B 且 B 兼容 C，则 A 兼容 C

### 兼容性示例

下面是一些具体的兼容性示例：

| Shape A | Shape B | 兼容性 | 说明 |
|---------|---------|--------|------|
| `24` | `32` | ❌ 不兼容 | size 不相等（24 ≠ 32） |
| `24` | `(4,6)` | ✅ 兼容 | 24 = 4×6，一维可以映射到二维 |
| `(4,6)` | `((2,2),6)` | ✅ 兼容 | 都是 24 个元素，4 可以分解为 (2,2) |
| `((2,2),6)` | `((2,2),(3,2))` | ✅ 兼容 | 都是 24 个元素，6 可以分解为 (3,2) |
| `24` | `((2,2),(3,2))` | ✅ 兼容 | 传递性：24 → (4,6) → ((2,2),6) → ((2,2),(3,2)) |
| `24` | `((2,3),4)` | ✅ 兼容 | 24 = 6×4，可以重组为 (2,3)×4 |
| `((2,3),4)` | `((2,2),(3,2))` | ❌ 不兼容 | 虽然 size 相同，但维度结构不匹配 |
| `((2,2),(3,2))` | `((2,3),4)` | ❌ 不兼容 | 反过来也不兼容 |
| `24` | `(24)` | ✅ 兼容 | 整数可以变成单元素 tuple |
| `(24)` | `24` | ❌ 不兼容 | tuple 不能直接变回整数 |
| `(24)` | `(4,6)` | ❌ 不兼容 | rank 不匹配 |

### 理解兼容性

**为什么 `((2,3),4)` 与 `((2,2),(3,2))` 不兼容？**

虽然两者的 size 都是 24（2×3×4 = 2×2×3×2），但它们的层次结构不同：

- `((2,3),4)` 的结构：外层 (2,3) 是 6 个元素，内层 4 个元素
- `((2,2),(3,2))` 的结构：外层 (2,2) 是 4 个元素，内层 (3,2) 是 6 个元素

这两种结构的索引方式不同，无法直接映射。

**为什么 `(24)` 与 `24` 不兼容？**

- `24` 是一个整数，表示一维数组
- `(24)` 是一个包含单个整数的 tuple，rank = 1
- 它们在 CuTe 的类型系统中是不同的类型

### 兼容性检查

在 CuTe 中，可以使用以下方式检查兼容性：

```cpp
// 创建不同的 shape
auto s1 = make_shape(24);
auto s2 = make_shape(Int<4>{}, Int<6>{});
auto s3 = make_shape(make_shape(Int<2>{}, Int<2>{}), Int<6>{});

// size 检查
static_assert(size(s1) == size(s2), "Size must match");
static_assert(size(s2) == size(s3), "Size must match");

// 兼容的布局可以相互转换
auto layout1 = make_layout(s1);
auto layout2 = make_layout(s2);
// 可以使用 s1 的坐标访问 layout2（通过线性化）
```

### 实际应用

布局兼容性在以下场景中非常重要：

1. **张量重塑（Reshape）**：将一维数据重新解释为多维张量
2. **分块（Tiling）**：将大矩阵分解为小块进行处理
3. **数据转换**：在不同的内存布局之间转换
4. **层次化处理**：将扁平数据组织成层次结构

例如，在 GEMM 中，我们可能需要将一个 `M×N` 的矩阵分块为 `(BlockM, TileM) × (BlockN, TileN)` 的层次化结构，这就需要确保形状的兼容性。