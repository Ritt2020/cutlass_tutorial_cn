> CuTe 是处理多维数据（Tensor）的模板抽象。学会了 CuTe 之后，你将会描述不同情形下的多维矩阵，而不需要关注矩阵内部具体元素的存取位置细节等，从而利用 CUTLASS 的相关特性。
>

## 环境要求
+ CUTLASS 3.x
+ NVCC with C++ 17

## 配置说明
+ **CuTe** 是一个仅 **header** 的库。你可以在 CUTLASS 的 **include/** 文件夹下找到。
+ 参考例子在 **CUTLASS** 目录下 **examples/cute/** 内。

## 引入 CuTe
+ 关键组件如下：

| 目录 | 内容 |
| --- | --- |
| [include/cute](https://github.com/NVIDIA/cutlass/tree/main/include/cute) | 每个 header 对应于 CuTe 的基本组件之一，如 [Layout](https://github.com/NVIDIA/cutlass/tree/main/include/cute/layout.hpp) 和 [Tensor](https://github.com/NVIDIA/cutlass/tree/main/include/cute/tensor.hpp)。 |
| [include/cute/container](https://github.com/NVIDIA/cutlass/tree/main/include/cute/container) | 实现类似 STL 的对象，如元组、数组和对齐数组。 |
| [include/cute/numeric](https://github.com/NVIDIA/cutlass/tree/main/include/cute/numeric) | 基本数字数据类型，包括非标准浮点类型、非标准整数类型、复数和整数序列。 |
| [include/cute/algorithm](https://github.com/NVIDIA/cutlass/tree/main/include/cute/algorithm) | 实用程序算法的实现，如 copy, fill, clear。 |
| [include/cute/arch](https://github.com/NVIDIA/cutlass/tree/main/include/cute/arch) | 特定架构的矩阵乘法和复制指令的 wrapper。 |
| [include/cute/atom](https://github.com/NVIDIA/cutlass/tree/main/include/cute/atom) | arch/ 目录的元信息和切分、分块等工具。 |


## 数据类型
### 整数类型
CuTe 提供了 **动态** 和 **静态** 整数类型。

| 特性 / 维度 | 动态整数 (run-time integer) | 静态整数 (compile-time integer) |
| --- | --- | --- |
| C++ 类型表示 | 普通整型，如 `int`, `size_t`, `uint16_t` | `std::integral_constant<Value>` 或 CuTe 的 `cute::C<Value>` / `Int<Value>` |
| 值确定时间 | 运行时才知道 | 编译时已知常量 |
| 与运算交互 | 与静态整数混用；大多数算术运算在运行时执行 | 支持重载算术操作，静态整数运算在编译期折叠为静态整数 |
| trait / 类型判断 | `cute::is_std_integral<T>` 为真；`cute::is_integral<T>` 为真 | `cute::is_static<T>` 为真；`cute::is_integral<T>` 为真；也可用 `cute::is_constant<N, T>` 判断 |
| 占用 / 存储 | 即时值，占用常规模板变量或内存 | 通常为空类型，不占运行时存储（作为类型参数） |
| 应用场景 | 尺寸 / 维度在运行时才知道的情形 | Tile 大小 / 固定维度 / 模板参数等已知常量场景 |
| 可互换性 | 在多数 CuTe 接口中可替换为静态整数 | 同样可以混用成动态整数（转换为普通整型） |


### 元组 Tuple
+ `cute::tuple`：CuTe 提供的元组类型，可在设备（CUDA kernel）和主机端使用，行为类似 `std::tuple`，但对模板参数种类有一定限制以便生成更高效代码。  
+ `IntTuple`：CuTe 定义为“要么是一个整数（动态 / 静态），要么是一个 `tuple`，其每个元素又是 `IntTuple`”。通过这个递归定义，CuTe 能表示嵌套结构的维度 / 形状 / 步幅等。  
+ `IntTuple` 的操作包括：`rank(...)`（元素个数），`get<I>(...)`（访问第 I 个元素），`depth(...)`（嵌套深度），`size(...)`（所有整数乘积）等。  
+ `Shape`、`Stride`、`Coord` 等在 CuTe 中都被定义为 `IntTuple` 的别名或实例。

---

#### 示例
下面是一个简单的例子，展示如何用 `cute::tuple` / `make_tuple` 构造一个嵌套的 `IntTuple`，以及如何访问其中的元素：

```cpp
#include <iostream>
#include "cutlass/experimental/cute/container/tuple.hpp"
using namespace cute;

int main() {
  // 一个简单的 IntTuple：动态整数 + 静态整数的组合
  auto t = make_tuple(int{2}, Int<3>{});
  // t 表示 (2, 3)

  // 嵌套结构：第三个元素又是一个 tuple
  auto nested = make_tuple(uint16_t{42},
                           make_tuple(Int<1>{}, int{3}),
                           Int<17>{});
  // nested 表示 (42, (1, 3), 17)

  // 访问元素 使用 get<index>()
  auto e0 = get<0>(nested);           // e0 是 uint16_t{42}
  auto e1 = get<1>(nested);           // e1 是 the tuple (Int<1>, int{3})
  auto e1_1 = get<1>(e1);              // e1_1 是 int{3}
  auto e2 = get<2>(nested);            // e2 是 Int<17>

  std::cout << \"e0 = \" << int(e0) << \"\\n\";          // 注意可能要转换为 int 打印
  std::cout << \"e1.second = \" << int(e1_1) << \"\\n\";
  std::cout << \"e2 (static) = \" << Int<17>{}.value << \"\\n\";

  return 0;
}
```

## 布局 Layout
布局 `Layout` 是一对 `IntTuple`：`Shape` 和 `Stride`。第一个元素定义了 `Layout` 的抽象_形状_，第二个元素定义了_步长_，从形状内的坐标映射到索引空间。

我们在 `Layout` 上定义了许多类似于 `IntTuple` 上定义的操作。

+ `rank(Layout)`：`Layout` 中的模式数量。相当于 `Layout Shape` 的元组的 `Size`。
+ `get<I>(Layout)`: `Layout` 的第 `I` 个布局模式， `I < rank`。
+ `depth(Layout)`：`Layout` 形状的深度。单个整数的深度为 0，整数元组的深度为 1，整数元组的深度为 2，等等。
+ `shape(Layout)`：`Layout` 的_形状_。
+ `stride(Layout)`：`Layout` 的_步长_。
+ `size(Layout)`：`Layout` 函数域的大小。等同于 `size(shape(Layout))`。
+ `cosize(Layout)`：`Layout` 函数协域的大小（不一定是范围）。相当于 `A(size(A)-1)+1`。

#### 构造布局
+ 构造传入 **shape** 和 **stride**。如果不传入 **stride**，则为默认 **LayoutLeft**。
+ **LayoutLeft** 为从左到右解释 **shape**（列主序）。**LayoutRight** 为从右到左解释 **shape**（行主序）。
+ 这里的关键是理解嵌套的 **Layout**，内层 **Layout** 展开后作为整体。

```cpp
// 一维：大小为 8（静态）
Layout s8 = make_layout(Int<8>{});   
// 等价于 [8]，stride = [1]，编译期常量的一维数组

// 一维：大小为 8（动态）
Layout d8 = make_layout(8);  
// 等价于 [8]，stride = [1]，运行时指定大小


// 二维：2 x 4，静态维度（默认列主序）
Layout s2xs4 = make_layout(make_shape(Int<2>{}, Int<4>{}));  
// shape = [2,4]，stride = [1,2]（列主序 ColumnMajor）
// 内存顺序：先存同一列，再存下一列


// 二维：2 x 4，混合静态和动态维度
Layout s2xd4 = make_layout(make_shape(Int<2>{}, 4));  
// shape = [2,4]，stride = [1,2]，与 s2xs4 等价，只是第二维是动态 int


// 指定 stride 的二维布局
Layout s2xd4_a = make_layout(make_shape(Int<2>{}, 4),
                             make_stride(Int<12>{}, Int<1>{}));  
// shape = [2,4], stride = [12,1]
// 每行之间跨度为 12，实际每行后多留 8 个空位


// 指定列主序（LayoutLeft）
Layout s2xd4_col = make_layout(make_shape(Int<2>{}, 4),
                               LayoutLeft{});  
// shape = [2,4]，stride = [1,2]（列主序 ColumnMajor）
// 内存顺序：先存一列，再存下一列


// 指定行主序（LayoutRight）
Layout s2xd4_row = make_layout(make_shape(Int<2>{}, 4),
                               LayoutRight{});  
// shape = [2,4]，stride = [4,1]（行主序 RowMajor）
// 内存顺序：先存一行，再存下一行


// 层次化布局：2 x (2x2)
Layout s2xh4 = make_layout(make_shape(2, make_shape(2,2)),
                           make_stride(4, make_stride(2,1)));  
// shape = [2,2,2]，stride = [4,2,1]
// 等价于一个 2x4 矩阵，用分层形式表示
// 内存顺序：最后两维 (2x2) 连续，外层步长为 4


// 用列主序重新解释 s2xh4 的 shape
Layout s2xh4_col = make_layout(shape(s2xh4),
                               LayoutLeft{});  
// shape = [2,2,2]，stride = [1,2,4]（列主序）
// 内存顺序：最内层维 stride 最小，最外层维 stride 最大

```

| Layout | rank | size | cosize | stride | 备注 |
| --- | --- | --- | --- | --- | --- |
| s8 / d8 | 1 | 8 | 8 | [1] | 一维 |
| s2xs4 | 2 | 8 | 8 | [1,2] | 默认 ColumnMajor |
| s2xd4 | 2 | 8 | 8 | [1,2] | 同上（第二维动态） |
| s2xd4_a | 2 | 8 | 16 | [12,1] | 有 padding |
| s2xd4_col | 2 | 8 | 8 | [1,2] | ColumnMajor |
| s2xd4_row | 2 | 8 | 8 | [4,1] | RowMajor |
| s2xh4 | 3 | 8 | 8 | [4,2,1] | 分块 2×(2×2) |
| s2xh4_col | 3 | 8 | 8 | [1,2,4] | ColumnMajor |


可以使用 `print2D(), printLayout()` 打印对应布局。

```cpp
> print2D(s2xs4)
  0    2    4    6
  1    3    5    7
> print2D(s2xd4_a)
  0    1    2    3
 12   13   14   15
> print2D(s2xh4_col)
  0    2    4    6
  1    3    5    7
> print2D(s2xh4)
  0    2    1    3
  4    6    5    7

> print_layout(s2xh4)
(2,(2,2)):(4,(2,1))
      0   1   2   3
    +---+---+---+---+
 0  | 0 | 2 | 1 | 3 |
    +---+---+---+---+
 1  | 4 | 6 | 5 | 7 |
    +---+---+---+---+
```



### 练习
+ 这里是一些练习题目，用于熟悉 Layout 的实现。
+ 请针对每个题目，仔细思考矩阵在二维空间内的元素顺序是怎么样的。然后和答案对比。

#### 题目
```cpp
auto L = make_layout(Int<4>{});

auto L = make_layout(make_shape(Int<2>{}, Int<3>{}),
                     LayoutRight{});

auto L = make_layout(make_shape(Int<2>{}, Int<3>{}),
                     LayoutLeft{});

auto L = make_layout(make_shape(Int<2>{}, Int<4>{}),
                     make_stride(Int<6>{}, Int<1>{}));

auto L = make_layout(make_shape(2, make_shape(2, 3)),
                     make_stride(6, make_stride(3, 1)));

auto L = make_layout(
    make_shape(Int<2>{}, Int<3>{}, Int<2>{}),
    make_stride(Int<12>{}, Int<4>{}, Int<1>{}));

```

#### 答案
```cpp
[0, 1, 2, 3]

[ 0   1   2 ]
[ 3   4   5 ]

[ 0   2   4 ]
[ 1   3   5 ]

[ 0   1   2   3 ]
[ 6   7   8   9 ]   // 注意 index=4,5 没用到（padding）

[ 0   1   2 ]
[ 3   4   5 ]

```

